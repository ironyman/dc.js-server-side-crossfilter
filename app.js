var express = require('express');
var path = require('path');
var favicon = require('serve-favicon');
var logger = require('morgan');
var cookieParser = require('cookie-parser');
var bodyParser = require('body-parser');
var anyToJSON = require('anytojson');
var crossfilter = require('crossfilter');
var d3 = require('d3');

var app = express();

// view engine setup
app.set('views', path.join(__dirname, 'views'));
app.set('view engine', 'jade');

// uncomment after placing your favicon in /public
//app.use(favicon(path.join(__dirname, 'public', 'favicon.ico')));
app.use(logger('dev'));
app.use(bodyParser.json());
app.use(bodyParser.urlencoded({ extended: false }));
app.use(cookieParser());
app.use(express.static(path.join(__dirname, 'public')));

app.get("/refresh", function (req, res, next) {
    var results = {};
    filter = req.query.filter ? JSON.parse(req.query.filter) : {}
    console.log('filter', filter);


    anyToJSON.csv({ path: "data/ndx.csv" }, function (data) {
        var dateFormat = d3.time.format('%m/%d/%Y');
        var numberFormat = d3.format('.2f');

        var dimensions = {};
        var groups = {};

        data.forEach(function (d) {
            d.dd = dateFormat.parse(d.date);
            d.month = d3.time.month(d.dd); // pre-calculate month for better performance
            d.close = +d.close; // coerce to number
            d.open = +d.open;
        });
        //console.log(data);

        //### Create Crossfilter Dimensions and Groups

        //See the [crossfilter API](https://github.com/square/crossfilter/wiki/API-Reference) for reference.
        var ndx = crossfilter(data);
        var all = ndx.groupAll();

        // Dimension by year
        var yearlyDimension = ndx.dimension(function (d) {
            return d3.time.year(d.dd).getFullYear();
        });

        // Do this crossfilter filtering manually. Normally this is done by dc.js.
        if (filter["yearlyDimension"] && filter["yearlyDimension"].length != 0) {
            yearlyDimension.filterFunction(d => filter["yearlyDimension"].indexOf(d) >= 0);
        }
        // Maintain running tallies by year as filters are applied or removed
        var yearlyPerformanceGroup = yearlyDimension.group().reduce(
            /* callback for when data is added to the current filter results */
            function (p, v) {
                ++p.count;
                p.absGain += v.close - v.open;
                p.fluctuation += Math.abs(v.close - v.open);
                p.sumIndex += (v.open + v.close) / 2;
                p.avgIndex = p.sumIndex / p.count;
                p.percentageGain = p.avgIndex ? (p.absGain / p.avgIndex) * 100 : 0;
                p.fluctuationPercentage = p.avgIndex ? (p.fluctuation / p.avgIndex) * 100 : 0;
                return p;
            },
            /* callback for when data is removed from the current filter results */
            function (p, v) {
                --p.count;
                p.absGain -= v.close - v.open;
                p.fluctuation -= Math.abs(v.close - v.open);
                p.sumIndex -= (v.open + v.close) / 2;
                p.avgIndex = p.count ? p.sumIndex / p.count : 0;
                p.percentageGain = p.avgIndex ? (p.absGain / p.avgIndex) * 100 : 0;
                p.fluctuationPercentage = p.avgIndex ? (p.fluctuation / p.avgIndex) * 100 : 0;
                return p;
            },
            /* initialize p */
            function () {
                return {
                    count: 0,
                    absGain: 0,
                    fluctuation: 0,
                    fluctuationPercentage: 0,
                    sumIndex: 0,
                    avgIndex: 0,
                    percentageGain: 0
                };
            }
        );
        // Dimension by full date
        var dateDimension = ndx.dimension(function (d) {
            return d.dd;
        });

        // Dimension by month
        var moveMonths = ndx.dimension(function (d) {
            return d.month;
        });
        // Group by total movement within month
        var monthlyMoveGroup = moveMonths.group().reduceSum(function (d) {
            return Math.abs(d.close - d.open);
        });
        // Group by total volume within move, and scale down result
        var volumeByMonthGroup = moveMonths.group().reduceSum(function (d) {
            return d.volume / 500000;
        });
        var indexAvgByMonthGroup = moveMonths.group().reduce(
            function (p, v) {
                ++p.days;
                p.total += (v.open + v.close) / 2;
                p.avg = Math.round(p.total / p.days);
                return p;
            },
            function (p, v) {
                --p.days;
                p.total -= (v.open + v.close) / 2;
                p.avg = p.days ? Math.round(p.total / p.days) : 0;
                return p;
            },
            function () {
                return { days: 0, total: 0, avg: 0 };
            }
        );
        // Create categorical dimension
        var gainOrLoss = ndx.dimension(function (d) {
            return d.open > d.close ? 'Loss' : 'Gain';
        });
        // Produce counts records in the dimension
        var gainOrLossGroup = gainOrLoss.group();

        // Determine a histogram of percent changes
        var fluctuation = ndx.dimension(function (d) {
            return Math.round((d.close - d.open) / d.open * 100);
        });
        var fluctuationGroup = fluctuation.group();

        // Summarize volume by quarter
        var quarter = ndx.dimension(function (d) {
            var month = d.dd.getMonth();
            if (month <= 2) {
                return 'Q1';
            } else if (month > 2 && month <= 5) {
                return 'Q2';
            } else if (month > 5 && month <= 8) {
                return 'Q3';
            } else {
                return 'Q4';
            }
        });
        var quarterGroup = quarter.group().reduceSum(function (d) {
            return d.volume;
        });
        // Counts per weekday
        var dayOfWeek = ndx.dimension(function (d) {
            var day = d.dd.getDay();
            var name = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
            // return day + '.' + name[day];
            return name[day];
        });

        // Do this crossfilter filtering manually. Normally this is done by dc.js.
        if (filter["dayOfWeekGroup"] && filter["dayOfWeekGroup"].length != 0 ) {
            dayOfWeek.filterFunction(d => filter["dayOfWeekGroup"].indexOf(d) >= 0);
        }

        var dayOfWeekGroup = dayOfWeek.group();
        console.log(dayOfWeek.top(Infinity))

        dimensions.yearlyDimension = yearlyDimension;
        dimensions.dayOfWeek = dayOfWeek;

        groups.yearlyPerformanceGroup = yearlyPerformanceGroup;
        groups.monthlyMoveGroup = monthlyMoveGroup;
        groups.volumeByMonthGroup = volumeByMonthGroup;
        groups.indexAvgByMonthGroup = indexAvgByMonthGroup;
        groups.quarterGroup = quarterGroup;
        groups.dayOfWeekGroup = dayOfWeekGroup;

        for (dimension in groups) {
            console.log('dimension', dimension);
            var group = groups[dimension];
            results[dimension] = { values: group.all(), top: group.top(1)[0].value };
        }

        res.writeHead(200, { 'content-type': 'application/json' });
        res.end((JSON.stringify(results)));

    });


});


app.use('/lib', express.static('node_modules/crossfilter/'));
app.use('/lib', express.static('node_modules/dc/'));
app.use('/lib', express.static('node_modules/d3/'));
app.get('/', function (req, res, next) {
    res.render('index', { title: 'Express' });
});

// catch 404 and forward to error handler
app.use(function (req, res, next) {
    var err = new Error('Not Found');
    err.status = 404;
    next(err);
});

// error handlers

// development error handler
// will print stacktrace
if (app.get('env') === 'development') {
    app.use(function (err, req, res, next) {
        res.status(err.status || 500);
        res.render('error', {
            message: err.message,
            error: err
        });
    });
}

// production error handler
// no stacktraces leaked to user
app.use(function (err, req, res, next) {
    res.status(err.status || 500);
    res.render('error', {
        message: err.message,
        error: {}
    });
});

module.exports = app;
